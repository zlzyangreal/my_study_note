# 类对象和类指针

**类的指针**：他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值)

**对象**：他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值)

指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数
* 指针变量是间接访问：指针变量是一种特殊的变量类型，它存储了一个内存地址，该地址指向另一个变量或对象的位置。通过指针变量，可以间接地访问和操作所指向的变量或对象。通过使用指针的解引用操作符（*），可以访问和修改指针所指向的值
```c++
    //解引用操作符
    int x = 10;
    int* ptr = &x; // 指向变量x的指针

    int value = *ptr; // 使用解引用操作符获取ptr所指向的值
    cout << value; // 输出：10

    *ptr = 20; // 使用解引用操作符修改ptr所指向的值
    cout << x; // 输出：20
```
* 可以实现多态：多态是面向对象编程中的一个重要概念，它允许以统一的方式处理不同类型的对象。通过使用父类的指针指向子类的对象，可以实现多态性。这意味着通过父类指针可以调用子类对象的成员函数，而不需要关心具体是哪个子类的对象
* 没有调用构造函数：指针变量本身并不是对象，它只是存储了一个内存地址。当通过指针访问对象时，不会调用构造函数
```c++
//例子
#include <iostream>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* ptr = new Derived(); // 使用父类指针指向子类对象

    ptr->print(); // 多态调用，输出 "Derived class"

    delete ptr;

    return 0;
}
```
直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）

类的对象:用的是**内存栈**,是个局部的临时变量

类的指针:用的是**内存堆**,是个永久变量,除非你释放它

应用时：
* 引用成员:   对象用"   .   "操作符;   指针用"   ->   "操作符
* 生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块

例子
----
***类指针：***
```c++
#include<iostream>
using namespace std;
 
class Test{
public:
    int a;
    Test(){
        a = 1;
    }
};
 
int main()
{
    Test* t1 = new Test();
    t1->a = 10;
    
    Test* t2 = new Test();
    t2->a = 5;
    
    cout << "&t1:" << t1 << " a = " << t1->a << endl;
    cout << "&t2:" << t2 <<  " a = " << t2->a <<endl;
    
    cout << "------------------------------" << endl;
    t2 = t1;
    cout << "&t1:" << t1 << " a = " << t1->a << endl;
    cout << "&t2:" << t2 <<  " a = " << t2->a <<endl;
    
    cout << "------------------------------" << endl;
    
    t1->a = 111;
    t2->a = 222;
    cout << "&t1:" << t1 << " a = " << t1->a << endl;
    cout << "&t2:" << t2 <<  " a = " << t2->a <<endl;
    
    delete t1;
    delete t2;

    return 0;
}
```
输出：
```c++
&t1:0x56119b31ee70 a=10
&t1:0x56119b31ee90 a=5
------------------------------
&t1:0x56119b31ee70 a=10
&t1:0x56119b31ee70 a=10
------------------------------
&t1:0x56119b31ee70 a=222
&t1:0x56119b31ee70 a=222
------------------------------
```
* 当执行t2 = t1时，实际上是将t1所指向的对象的地址赋值给了t2，这意味着t2和t1指向了同一个对象
* 因为是同一个对象，所以修改的是同一个东西

***类对象：***
```c++
#include <iostream>
using namespace std;
class Test{
public:
    int a;
    Test(){
        a = 1;
    }
};
int main()
{
    Test t1;
    t1.a = 10;
    
    Test t2;
    t2.a = 5;
    
    cout << "&t1:" << &t1 << " a = " << t1.a << endl;
    cout << "&t2:" << &t2 <<  " a = " << t2.a <<endl;
    
    cout << "------------------------------" << endl;
    t2 = t1;
    cout << "&t1:" << &t1 << " a = " << t1.a << endl;
    cout << "&t2:" << &t2 <<  " a = " << t2.a <<endl;
    
    cout << "------------------------------" << endl;
    
    t1.a = 111;
    t2.a = 222;
    cout << "&t1:" << &t1 << " a = " << t1.a << endl;
    cout << "&t2:" << &t2 <<  " a = " << t2.a <<endl;
    
    return 0;
}
```
结果：
```c++
&t1:0x56119b31ee70 a=10
&t1:0x56119b31ee90 a=5
------------------------------
&t1:0x56119b31ee70 a=10
&t1:0x56119b31ee90 a=10
------------------------------
&t1:0x56119b31ee70 a=111
&t1:0x56119b31ee90 a=222
------------------------------
```