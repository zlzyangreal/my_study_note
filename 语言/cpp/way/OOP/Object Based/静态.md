# static静态

静态数据存在的意义
-----------------
可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

在C/C++中``static``的作用
------------------------
* 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放
* static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以
* static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0
* 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰
* 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）

静态变量与普通变量的对比
-----------------------
***静态全局变量***
-----------------
特点：
* **静态变量都在全局数据区分配内存**（包括静态局部变量）
* 未经初始化的静态全局变量会被程序自动初始化为0
* 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的

区别：
* 全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量
* 全局静态变量是用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用

***静态局部变量***
-----------------
特点：
* 该变量在全局数据区分配内存
* 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化
* 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0
* 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束

一般程序把新产生的**动态数据**存放在**堆区**，**函数内部的自动变量**存放在**栈区**。自动变量一般会随着函数的退出而释放空间，**静态数据**（即使是函数内部的静态局部变量）也存放在**全局数据区**。全局数据区的数据并不会因为函数的退出而释放空间

``static``在c++中用法
--------------------
```c++
class A
{
public: 
    void setup{...};
    static double m_rate;
    static void set_rate(const double& x){m_rate = x;}
};

double A::m_rate = 8.0;

int main()
{
    A::set_rate(5.0);//通过object调用
    //!!!单例模式不可以以下方式调用!!!
    A a;
    a.set_rate(7.0);//通过class name调用
}
```
注意：
~~~
1.不能通过类名来调用类的非静态成员函数  A::setup();  ，非静态成员必须创建对象

正确写法：  a.setup();
~~~
~~~
2.类对象可以使用静态成员函数和非静态函数成员,但是注意数据的分区

a.setup();
a.set_rate(7.0);
~~~
~~~
3.静态成员函数中不能引用非静态成员，因为存在分区问题静态函数处于静态区(全局数据区)，但是类的非静态成员函数可以调用用静态成员函数这很容易理解
~~~


