# gcc链接库

在widows平台下，静态链接库是.lib文件，动态库文件是.dll文件。在linux平台下，静态链接库是.a文件，动态链接库是.so文件。这里主要讲在linux平台下的动态库和静态库的生成以及链接

库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。本质上说来**库是一种可执行代码的二进制形式**（注，其本身不可执行），可以被操作系统载入内存执行

***下例文件tree结构***
~~~
.
|-inc
|  |-swap.h
|-main.cpp
|-src
   |-swap.cpp
~~~

静态库( 静态链接库)
------------------
在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，因此对应的链接方式为静态链接。其实一个静态链接库可以简单看成一组目标文件(.o/.obj文件)的集合，即很多目标文件经过压缩打包后形成的一个文件

特点：
* 静态库对函数库的链接是放在编译时期完成

* 程序在运行时对函数库再唔瓜葛，一直方便

* 浪费空间和资源，因为所有相关的目标文件和牵涉到的函数库被链接合成一个可执行文件

linux下使用ar工具（windows下用lib.exe），可以将目标文件压缩到一起，并且对其行编号和索引，一便于查找和索引

**操作步骤**
1.   到cpp文件目录下，生成`.o`文件,`g++ swap.cpp -c -I../inc`
* `..`返回上一级,`.`当前级
2.   生成`.a`文件,`ar rs libswap.a swap.o`
* ar工具，该工具是用于操作归档文件（archive files）的命令行工具
* r选项表示替换（replace），它告诉ar工具如果目标文件已经存在于静态库中，则替换它；如果目标文件不存在，则将其添加到静态库中
* s选项表示更新符号表（update symbol table），它告诉ar工具在静态库中更新符号表，以便可以在链接时解析符号引用
* 在这个命令中，ar工具被用来创建一个名为libswap.a的静态库，其中包含一个名为swap.o的目标文件
3.   到主目录生成可执行文件,`g++ main.cpp -lswap -Lsrc -Iinc -o static_main`

动态库(动态链接库)
-----------------
在程序编译是并不会被连接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题

总结：
* 动态库把对一些库函数的链接载入推迟到程序运行时期
* 可以实现进程之间的资源共享，（动态库也成为共享库）
* 将一些程序升级变得简单
* 设置可以真正做到链接载入完全由程序员在程序代码中控制（显式调用）

Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便。与windows系统下的格式不同。与创建静态库不同的是，不需要打包工具，直接使用编译器即可创建动态库

**操作步骤**
1. 在cpp文件目录下，生成`.so`文件，`g++ swap.cpp -I../inc -fPIC -shared -o libswap.so`
* `-fPIC`这是一个编译选项，用于生成位置无关代码（Position Independent Code，PIC）。位置无关代码可以在内存中的任意位置加载和执行，适用于共享库
* `-shared`这是一个链接选项，用于指示链接器生成一个共享库。共享库是一种可以被多个程序共享和重用的可执行代码文件
2. 在主文件下生成执行文件(不可直接执行),`g++ main.cpp -Iinc -Lsrc -lswap -o share_main`
* **该文件不可直接执行，需要配置**`LD_LIBRARY_PATH=src ./share_main`